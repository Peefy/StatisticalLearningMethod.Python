
class Chapter7:
    """
    第7章 支持向量机
    """
    def __init__(self):
        """
        第7章 支持向量机
        """
        pass

    def note(self):
        """
        chapter7 note
        """
        print('第7章 支持向量机')
        print('支持向量机(support vector machines, SVM)是一种二类分类器.它的基本模型是定义在特征空间上的间隔最大的线性分类器,',
            '间隔最大使它有别于感知机；支持向量机还包括核技巧,这使它成为实质上的非线性分类器.',
            '支持向量机的学习策略就是间隔最大化,可形式化为一个求解凸二次规划(convex quadratic programming)的问题,',
            '也等价于正则化的合页损失函数的最小化问题.支持向量机的学习算法是求解凸二次规划的最优化算法.')
        print('支持向量机学习方法包含构建由简至繁的模型:线性可分支持向量机、线性支持向量机及非线性支持向量机.',
            '简单模型是复杂模型的基础,也是复杂模型的特殊情况.当训练数据线性可分时,通过硬间隔最大化,',
            '也学习一个线性的分类器,即线性支持向量机,又称为软间隔支持向量机;',
            '当训练数据线性不可分时,通过使用核技巧及软间隔最大化,学习非线性支持向量机.')
        print('当输入空间为欧式空间或离散集合、特征空间为希尔伯特空间时,',
            '核函数表示将输入从输入空间映射到特征空间得到的特征向量之间的内积',
            '通过使用核函数可以学习非线性支持向量机,等价于隐式地在高维的特征空间中学习线性支持向量机.',
            '核方法是比支持向量机更一般的机器学习方法')
        print('7.1 线性可分支持向量机与硬间隔最大化.')
        print('7.1.1 线性可分支持向量机')
        print('考虑一个二类分类问题.假设输入空间与特征空间为两个不同的空间.',
            '输入空间为欧式空间或离散集合,特征空间为欧式空间或希尔伯特空间.',
            '线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应,并将输入空间中的输入映射为特征空间中的特征向量.',
            '非线性支持向量机利用一个从输入空间到特征空间的非线性映射将输入映射为特征向量.',
            '输入都由输入空间转换到特征空间,支持向量机的学习是在特征空间进行的.')
        print('假设给定一个特征空间上的训练数据集T={(x1,y1),(x2,y2),...,(xn,yn)}')
        print('其中,xi∈X=R^n,yi∈Y={+1,-1},i=1,2,...,N,xi为第i个特征向量,也称为实例,',
            'yi为xi的类标记,当yi=+1时,称xi为正例;当yi=-1时,称xi为负例,',
            '(xi,yi)称样本点.再假设训练数据集是线性可分的.')
        # !SVM学习的目标是在特征空间中找到一个分离超平面,能将实例分到不同的类.
        print('SVM学习的目标是在特征空间中找到一个分离超平面,能将实例分到不同的类.')
        print('分离超平面对应于方程w·x+b=0,由法向量w和截距b决定,可用(w,b)来表示.')
        print('分离超平面将特征空间划分为两部分,一部分是正类,一部分是负类.',
            '法向量指向一侧为正类,另一侧为负类.')
        print('一般地,当训练数据集线性可分时,存在无穷个分离超平面可将两类数据正确分开.',
            '感知机利用误分类最小的策略,求得分离超平面,不过这时的解有无穷多个.',
            '线性可分支持向量机利用间隔最大化求最优分离超平面,这时,解是唯一的')
        print('定义7.1 (线性可分支持向量机)给定线性可分训练数据集,通过间隔最大化或等价地求解相应的',
            '凸二次规划问题学习得到的分离超平面为：w*·x+b*=0 以及相应的决策函数:f(x)=sign(w*·x+b*)',
            '称为线性可分支持向量机')
        print('7.1.2 函数间隔和几何间隔')
        print('在图7.1中,有A,B,C三个点,表示3个实例,均在分离超平面的正类一侧,预测它们的类.')
        print('一般来说,一个点距离分离超平面的远近可以表示分类预测的确信程度.在超平面wx+b=0确定的情况下',
            '|wx+b|能够相对地表示点x距离超平面的远近.而wx+b的符号与类标记y的符号是否一致能够表示分类是否正确.',
            '所以可用量y(wx+b)来表示分类的正确性及确信度,这就是函数间隔的概念.')
        print('定义7.2（函数间隔）对于给定的训练数据集T和超平面(w,b),定义超平面(w,b)关于样本点(xi,yi)的函数间隔为:',
            'yi=yi(w·wi+b).定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点(xi,yi)的函数间隔之最小值,即',
            'y\'=minyi')
        print('函数间隔可以表示分类预测的正确性及确信度.但是选择分离超平面时,只有函数间隔还不够.',
            '因为只要成比例地改变w和b，例如将它们改为2w和2b,超平面并没有改变,',
            '但函数间隔却成为原来的2倍.可以对分离超平面的法向量w加某些约束,如规范化,||w||=1,使得间隔是确定的.',
            '这时函数间隔成为几何间隔(geometric margin)')
        print('图7.2给出了超平面(w,b)及其法向量w.点A表示某一实例xi,其类标记为yi=+1.',
            '点A与超平面(w,b)的距离由线段AB给出,记作yi=w/||w||·xi+b/||w||')
        print('其中,||w||为w的L2范数.这是点A在超平面正的一侧的情形.如果点A在超平面负的一侧,即yi=-1,',
            '那么点与超平面的距离yi=-(w/||w||·xi+b/||w||)')
        print('一般地,当样本点(xi,yi)被超平面(w,b)正确分类时,点xi与超平面(w,b)的距离是',
            'di=yi(w/||w||·xi+b/||w||)')
        print('定义7.3(几何间隔)对于给定的训练数据集T和超平面(w,b),定义超平面(w,b)关于样本点(xi,yi)的几何间隔为,',
            'di=yi(w/||w||·xi+b/||w||)')
        print('定义超平面(w,b)关于训练数据集T的几何间隔为超平面(w,b)',
            '关于T中所有样本点(xi,yi)的几何间隔之最小值,即d=mindi')
        print('超平面(w,b)关于样本点(xi,yi)的几何间隔一般是实例点到超平面的带符号的距离,',
            '当样本点被超平面正确分类时就是实例点到超平面的距离.')
        print('从函数间隔和几何间隔的定义可知,函数间隔和几何间隔有下面的关系:di=di/||w||;d=d/||w||')
        print('如果||w||=1,那么函数间隔和几何间隔相等.如果超平面参数w和b成比例地改变(超平面没有改变),',
            '函数间隔也按此比例改变,而几何间隔不变.')
        print('7.1.3 间隔最大化')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')

chapter7 = Chapter7()

def main():
    chapter7.note()

if __name__ == '__main__':
    main()