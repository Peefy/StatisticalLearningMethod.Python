
class Chapter9:
    """
    第9章 EM算法及其推广
    """
    def __init__(self):
        """
        第9章 EM算法及其推广
        """
        pass

    def note(self):
        """
        chapter8 note
        """
        print('第9章 EM算法及其推广')
        print('EM算法是一种迭代算法,1977年由Dempster等人总结提出,',
            '用于含有隐变量(hidden variable)的概率模型参数的极大似然估计',
            '或极大后验概率估计.EM算法的每次迭代由两步组成:E步,求期望(expectation);M步,',
            '求极大.所以这一算法称为期望极大算法(expectation maximization algorithm),',
            '简称EM算法.EM算法的一个应用:高斯混合模型,以及EM算法的推广-GEM算法')
        print('9.1 EM算法的引入')
        print('概率模型有时含有观测变量(observable variable),又含有隐变量或潜在变量',
            '如果概率模型的变量都是观测变量,那么给定数据,可以直接用极大似然估计法,',
            '或者贝叶斯估计法估计模型参数.但是,当模型含有隐变量时,就不能简单地使用这些估计方法.',
            'EM算法就是含有隐变量的概率模型参数的极大似然估计法,或极大后验概率估计法.',
            '仅讨论极大似然估计,极大后验概率估计与其类似.')
        print('9.1.1 EM算法')
        print('例9.1 (三硬币模型)假设有3枚硬币,分别记作A,B,C.这些硬币正面出现的概率分别是pi,p和q.',
            '进行如下投掷硬币试验,先掷硬币A,根据其结果选出硬币B或硬币C;然后掷选出的硬币,掷硬币的结果,',
            '出现正面记作1,出现反面记作0;独立地重复n次试验(n=10),观测结果如下:1,1,0,1,0,1,0,1,1')
        print('假设只能观测到掷硬币的结果,不能观测掷硬币的过程.')
        print('解:三硬币模型可以写作:')
        print('  P(y|a)=∑P(y,z|a)=∑P(z|a)P(y|z,a)=pip^y(1-p)^(1-y)q^y(1-q)^(1-y)')
        print('这里,随机变量y是观测变量,表示一次试验观测的结果是1或0;随机变量z是隐藏变量,',
            '表示未观测到的掷硬币A的结果,a=(pi,p,q)是模型观测参数.',
            '这一模型是以上数据的生成模型.注意:随机变量y的数据可以观测,随机变量z的数据不可观测.')
        print('将观测数据表示为Y=(Y1,Y2,...,Yn)^T,未观测数据表示为Z=(Z1,Z2,...,Zn)^T,',
            '则观测数据的似然函数为:P(Y|a)=∑P(Z|a)P(Y|Z,a)')
        print('即P(Y|a)=∏[pip^yj(1-p)^(1-yj)+(1-pi)q^yj(1-q)^(1-yj)]')
        print('考虑求模型参数a=(pi,p,q)的极大似然估计,即a=argmaxlogP(Y|a)')
        print('EM算法首先选取参数的初值,记作a(0)=(pi(0),p(0),q(0)),然后通过下面的步骤迭代计算参数的估计值,',
            '直至收敛为止.第i次迭代参数的估计值为a(i)=(pi(i),p(i),q(i)).EM算法的第i+1次迭代如下.')
        print('E步:计算在模型参数pi(i),p(i),q(i)下观测数据yj来自掷硬币B的概率:')
        print('  计算u(i+1)')
        print('M步:计算模型参数的新估计值pi(i+1),p(i+1),q(i+1)')
        print('进行数字计算.假设模型参数的初值取为:')
        print('  pi(0)=0.5,p(0)=0.5,q(0)=0.5')
        print('对yj=1与yj=0均有uj(i)=0.5.')
        print('利用迭代公式,得到:pi(1)=0.5,p(1)=0.6,q(1)=0.6')
        print('  uj(2)=0.5,j=1,2,...,10')
        print('继续迭代,得:pi(2)=0.5,p(2)=0.6,q(2)=0.6')
        print('于是得到模型参数a的极大似然估计为:pi=0.5,p=0.6,q=0.6')
        print('pi=0.5表示硬币是均匀的.')
        print('如果选择初值pi(0)=0.4,p(0)=0.6,q(0)=0.7,那么得到的模型参数的极大似然估计是',
            'pi=0.4064,p=0.5368,q=0.6432.这就是说,EM算法与初值的选择有关,',
            '选择不同的初值可能得到不同的参数估计值')
        print('一般地,用Y表示观测随机变量的数据,Z表示隐随机变量的数据.Y和Z连在一起称为完全数据(complete-data)',
            '观测数据Y又称为不完全数据(incomplete-data).假设给定观测数据Y,其概率分布是P(Y|a),',
            '其中a是需要估计的模型参数,那么不完全数据Y的似然函数是P(Y|a),',
            '对数似然函数L(a)=logP(Y|a);假设Y和Z的联合概率分布是P(Y,Z|a),',
            '那么完全数据的对数似然函数是logP(Y,Z|a)')
        # !EM算法通过迭代求L(a)=logP(Y|a)的极大似然估计.每次迭代包含两步
        print('EM算法通过迭代求L(a)=logP(Y|a)的极大似然估计.每次迭代包含两步：',
            'E步,求期望;M步,求极大化.下面介绍EM算法')
        print('算法9.1(EM算法)')
        print('输入:观测变量数据Y,隐藏量数据Z,联合分布P(Y,Z|a),条件分布P(Z|Y,a)')
        print('输出:模型参数a.')
        print('(1) 选择参数的初值a(0),开始迭代;')
        print('(2) E步:记a(i)为第i次迭代参数a的估计值,在第i+1次迭代的E步,计算',
            'Q(a,a(i))=Ez[logP(Y,Z|a)|Y,a(i)]=∑logP(Y,Z|a)P(Z|Y,a(i))')
        print('这里,P(Z|Y,a(i))是在给定观测数据Y和当前的参数估计a(i)下隐藏变量数据Z的条件概率分布;')
        print('(3) M步:求使Q(a,a(i))极大化的a,确定第i+1次迭代的参数的估计值a(i+1)=argmaxQ(a,a(i))')
        print('(4) 重复第(2)步和第(3)步,直到收敛.')
        print('函数Q(a,a(i))=Ez[logP(Y,Z|a)|Y,a(i)]=∑logP(Y,Z|a)P(Z|Y,a(i))是EM算法的核心,称为Q函数')
        print('定义9.1(Q函数)完全数据的对数似然函数logP(Y,Z|a)关于在给定观测数据Y和当前参数a(i)',
            '下对未观测数据Z的条件概率分布P(Z|Y,a(i))的期望称为Q函数,即',
            'Q(a,a(i))=Ez[logP(Y,Z|a)|Y,a(i)]')
        print('下面关于EM算法作几点说明:')
        print('步骤(1) 参数的初值可以任意选择,但需注意EM算法对初值是敏感的.')
        print('步骤(2) E步求Q(a,a(i)).Q函数式中Z是未观测数据,Y是观测数据.',
            '注意,Q(a,a(i))的第1个变元表示要极大化的参数,第2个变元表示参数的当前估计值.',
            '每次迭代使似然函数增大或达到局部极值.')
        print('步骤(3) M步求Q(a,a(i))的极大化,得到a(i+1),完成一次迭代a(i)->a(i+1).',
            '后面将证明每次迭代使似然函数增大或达到局部极值.')
        print('步骤(4) 给出停止迭代的条件,一般是对较小的正数e1,e2,',
            '若满足||a(i+1)-a(i)||<e1或||Q(a(i+1),a(i))-Q(a(i),a(i))||<e2则停止迭代')
        print('9.1.2 EM算法的导出')
        print('面对一个含有隐藏变量的概率模型,目标是极大化观测数据(不完全数据)Y关于参数a的对数似然函数,',
            '即极大化L(a)=logP(Y|a)=log∑P(Y,Z|a)=log(∑P(Y|Z,a)P(Z|a))')
        print('这一极大化的主要困难是式子中有未观测数据并有包含和(或积分)的对数')
        print('事实上,EM算法是通过迭代逐步近似极大化L(a)的.假设在第i次迭代后a的估计值是a(i).',
            '希望新估计值a能使L(a)增加,即L(a)>L(a(i)).并逐步达到极大值.为此,考虑两者的差:')
        print('L(a)-L(a(i))=log(∑P(Y|Z,a)P(Z|a))-logP(Y|a(i))')
        print('可以利用Jensen不等式(Jensen inequality)得到其下界,')
        print('a(i+1)=argmaxQ(a,a(i))等价于EM算法的一次迭代,即求Q函数及其极大化.',
            'EM算法是通过不断求解下界的极大化逼近对数似然函数极大化的算法.')
        print('图中给出EM算法的直观解释.图中上方曲线为L(a),下方曲线为B(a,a(i)).',
            'B(a,a(i))为对数似然函数L(a)的下界,两个函数在a=a(i)处相等.',
            'EM算法找到下一个点a(i+1)使函数B(a,a(i))极大化,也使函数Q(a,a(i))极大化.',
            '这时由于L(a)>=B(a,a(i)),函数B(a,a(i))的增加,',
            '保证对数似然函数L(a)在每次迭代中也是增加的.',
            'EM算法在点a(i+1)重新计算Q函数值,进行下一次迭代.',
            '在这个过程中,对数似然函数L(a)不断增大.')
        print('结论：EM算法不能保证找到全局最优解')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
        print('')
  
chapter9 = Chapter9()

def main():
    chapter9.note()

if __name__ == '__main__':
    main()